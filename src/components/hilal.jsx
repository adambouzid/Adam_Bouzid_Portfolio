/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Optimized for Portfolio Hero Section
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { useMotionValue, useSpring } from 'motion/react'
import { useFrame, useThree } from '@react-three/fiber'
import * as THREE from 'three'

export function Hilal(props) {
  const group = useRef()
  const baseRotation = useRef([0, 0, 0])
  const [glowIntensity, setGlowIntensity] = useState(0)
  const { nodes, materials } = useGLTF('/models/hilal.glb')
  const { viewport } = useThree()
  const isMobile = props.isMobile || false
  
  // Animation de flottement doux comme une lune
  const yPosition = useMotionValue(5)
  const ySpring = useSpring(yPosition, { damping: 40, stiffness: 50 })
  
  useEffect(() => {
    ySpring.set(-0.5)
  }, [ySpring])
  
  // Synchroniser la rotation de base depuis les props (pour le responsive)
  useEffect(() => {
    const r = props.rotation || [0, 0, 0]
    baseRotation.current = r
    if (group.current) {
      group.current.rotation.set(r[0], r[1], r[2])
    }
  }, [props.rotation])

  // Animation: flottement + léger contrôle souris + proximity glow
  useFrame((state) => {
    const time = state.clock.elapsedTime
    if (!group.current) return
    group.current.position.y = ySpring.get() + Math.sin(time * 0.3) * 0.1

    const [bx, by, bz] = baseRotation.current
    const mx = state.mouse.x // -1..1
    const my = state.mouse.y // -1..1
    
    // Mouse control rotation - only on desktop
    if (!isMobile) {
      group.current.rotation.x = bx + my * 0.08
      group.current.rotation.y = by + mx * 0.12
      group.current.rotation.z = bz + Math.sin(time * 0.2) * 0.05
    } else {
      // On mobile, keep base rotation with gentle float
      group.current.rotation.x = bx
      group.current.rotation.y = by
      group.current.rotation.z = bz + Math.sin(time * 0.2) * 0.05
    }

    // Mouse proximity glow effect - ONLY on desktop
    if (!isMobile) {
      const hilalPos = group.current.position.clone()
      const mouseX = (mx * viewport.width) / 2
      const mouseY = (my * viewport.height) / 2
      
      const distance = Math.sqrt(
        Math.pow(hilalPos.x - mouseX, 2) + 
        Math.pow(hilalPos.y - mouseY, 2)
      )
      
      // Glow increases when mouse is closer (within 3 units)
      const maxDistance = 3
      const proximity = Math.max(0, 1 - (distance / maxDistance))
      const newGlow = proximity * 3 // 0 to 3
      setGlowIntensity(newGlow)
      
      // Send glow intensity to parent for page-wide effect
      if (props.onGlowChange) {
        props.onGlowChange(newGlow)
      }
    } else {
      // On mobile, keep glow at 0
      if (glowIntensity !== 0) {
        setGlowIntensity(0)
        if (props.onGlowChange) {
          props.onGlowChange(0)
        }
      }
    }
  })
  
  return (
    <group 
      ref={group}
      {...props} 
      dispose={null}
      scale={props.scale || 1.5}
      position={props.position || [0, 0, 0]}
      rotation={props.rotation || [0, 0, 0]}
    >
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.material.geometry}
        material={materials['Material.001']}
      />
      
      {/* Subtle point light that glows with mouse proximity */}
      <pointLight 
        color={'#60a5fa'} 
        intensity={isMobile ? 0.2 : (0.5 + glowIntensity * 1.5)} 
        distance={3} 
        position={[0, 0, 0.8]} 
      />
      
      {/* Very subtle rim light on the back */}
      <pointLight 
        color={'#3b82f6'} 
        intensity={isMobile ? 0.1 : (0.3 + glowIntensity * 0.8)} 
        distance={2} 
        position={[0, 0, -0.5]} 
      />
    </group>
  )
}

useGLTF.preload('/models/hilal.glb')